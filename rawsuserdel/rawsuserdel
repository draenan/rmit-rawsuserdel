#!/usr/bin/env perl -T
# $Id$
$|++;
use strict;
use warnings;
use File::Basename;
use Getopt::Std;
use File::Find;
use POSIX "strftime";
use Sys::Hostname;
use DBI;

$Getopt::Std::STANDARD_HELP_VERSION = 1;
our $VERSION = 0.1;

delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};
$ENV{PATH} = "/bin:/usr/bin";

$SIG{"INT"} = "INT_handler";

my $cmd_name = basename("$0");
my $hostname = hostname;

my %options = ();
if (!getopts("c:h:nAUTvVd:u:m:f:", \%options)) {
    exit 1;
}

$options{n} = 1;

if ($options{V}) {
    VERSION_MESSAGE();
    exit 0;
}

if ( (!$options{f} and @ARGV == 0) or ($options{T} and $options{U}) or
      ($options{U} and $options{A}) or ($options{T} and $options{A}) ) {
    VERSION_MESSAGE();
    HELP_MESSAGE();
    exit 1;
}

#die "Need to run as root.\n" unless ($< == 0);

my $conf_file;

if ($options{c}) {
    $conf_file = $options{c};
}
else {
    $conf_file = find_conf();
}

die "ERROR: Could not find config file.\n" unless defined $conf_file;

my %config = (
    min_uid   => "500",
    db_host   => "localhost",
    db_name   => "example",
    db_user   => "admin",
    db_passwd => "s3kr1t",
);

parse_config($conf_file, \%config);
enact_config(\%config);

my $lfh = fileno(LOG);

my %passwd = ();
hash_passwd(\%passwd) unless defined $options{T};

my @users = ();
get_users(\@users);

my %victims = ();
get_victims(\%victims, \@users);

my %ac_databases = ();
my %ac_db_creds = ();
if ($options{A}) {
    if (!$options{T} and !$options{U}) {
        foreach my $user (@{$victims{accounts}}) {
            find({ wanted => \&autoconf, untaint => 1 }, "/Users/$user/public_html/");
        }
    }
    elsif ($options{U}) {
        print "The \"-U\" option is set, ignoring \"-A\" option.\n" if defined $options{v};
    }
    else {
        print "The \"-T\" option is set, igonoring \"-A\" option.\n" if defined $options{v};
    }
}


delete_users(\$victims{accounts}) unless defined $options{T};
delete_tables(\$victims{tables}, \%ac_databases, \%ac_db_creds) unless defined $options{U};

close_log() if defined $lfh;

exit 0;

#### Functions.

sub INT_handler {
    print "\nCaught SIGINT, exiting\n";
    if (defined fileno(LOG)) {
        log_message("Caught SIGINT, exiting");
        close_log();
    }
    exit 1;
}

sub find_conf {
    if (-e "$0".".cf" ) {
        return "$0".".cf";
    }
    else {
        foreach my $default_file ( ("/usr/local/etc/$cmd_name.cf", "/etc/$cmd_name.cf") ) {
            if (-e $default_file) {
                return $default_file;
            }
        }
   }
}

sub parse_config {
    my ($file, $config) = @_;
    my $line;
    open FILE, "<", $file or die "ERROR: Could not open $file\n";
    while (<FILE>) {
        $line = $_;
        chomp ($line);
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;
        if ($line !~ /^#/ and $line ne "") { 
            $line =~ s/^(\S*)\s+=\s+(\S*)$/$1=$2/;
            $line =~ s/^(.*)=[\'\"](.*)[\'\"]$/$1=$2/;
            my ($key, @value) = split /=/, $line;
            $$config{$key} = join '=', @value;
        }
    }
    close FILE;
}

sub enact_config {
    my ($config) = @_;
    my $msg;
    my $lfh;
    if ($$config{log_file} and !$options{n}) {
        print "Opening log file\n";
        open_log($$config{log_file});
    }
    if (!$options{T} and defined $options{m}) {
        if ($options{m} =~ /^(\d+)$/ and $options{m} >= 500 ) {
            $$config{min_uid} = $1;
        }
        else {
            die "ERROR:  Invalid minimum UID specified.\n";
        }
    }
    elsif ($options{T} and defined $options{m}) {
        print "The \"-T\" option is set, ignoring minimum UID override.\n" if defined $options{v};
    }

    if (!$options{U}) {
        if ($options{h}) {
            $$config{db_host} = $options{h};
        }

        if ($options{d}) {
            $$config{db_name} = $options{d};
        }

        if ($options{u}) {
            $$config{db_user} = $options{u};
            print "Enter password for \"$$config{db_name}\" user \"$$config{db_user}\": ";
            system ("stty -echo");
            $$config{db_passwd} = <STDIN>; 
            chomp($$config{db_passwd});
            system ("stty echo");
            print "\n";
        }

        print "Testing connection to database \"$$config{db_name}\" (Host: \"$$config{db_host}\" User: \"$$config{db_user}\") ...\n" if defined $options{v};
        my $dsn = "dbi:mysql:$$config{db_name}:$$config{db_host}";
        my $dbh;
        eval {
            $dbh = DBI->connect($dsn, $$config{db_user}, $$config{db_passwd}, {
                                PrintError => 0,
                                AutoCommit => 1, }) or die;
        };
        if ($@) {
            dbi_error();
            exit 1;
        }
        eval {
            $dbh->disconnect or die;
        };
        if ($@) {
            dbi_error();
            exit 1;
        }
        print "Test successful.\n" if defined $options{v};
    }
    elsif ($options{U} and ($options{h} or $options{d} or $options{u})) {
        print "The \"-U\" option is set, ignoring database config overrides.\n" if defined $options{v};
    }
}

sub open_log {
    my ($log_file) = @_;
    if ($log_file =~ /(^[\w\.-\/]+)$/ ) {
        $log_file = $1;
        if (-e $log_file) {
            open LOG, ">>", $log_file or die "ERROR: Could not open log file.\n";
        }
        else {
            open LOG, ">", $log_file or die "ERROR: Could not open log file.\n";
        }
        log_message("--- $cmd_name BEGIN ---");
    }
    else {
        die "ERROR: Invalid log file specified.\n";
    }
}

sub close_log {
    log_message("--- $cmd_name END ---");
    close LOG;
}

sub log_message {
    my @msg = @_;
    chomp(@msg);
    printf LOG "%s %s %s[%s]: %s\n", strftime("%b %e %H:%M:%S", localtime), $hostname, $cmd_name, $$, @msg;
}

sub hash_passwd {
    my ($passwd) = @_;
    setpwent();
    while (my ($user, $uid) = (getpwent())[0,2]) {
        $$passwd{$user} = 1  unless $uid < $config{min_uid} or $user =~ /^(?:root|no(?:body|access))/;
    }
    endpwent();
}

sub get_users {
    my ($users) = @_;
    my $msg;
    if ($options{f}) {
        eval {
            open FILE, "<", $options{f} or die;
        };
        if ($@) {
            $msg = "ERROR: Could not open file \"$options{f}\"\n";
            print STDERR $msg;
            if ($config{log_file}) {
                log_message($msg);
                close_log();
            }
            exit 1; 
        }
        @$users = <FILE>;
        close FILE;
    }
    else {
        push @$users, @ARGV;
    }
}

sub get_victims {
    my ($victims, $users) = @_;
    my $msg;
    foreach my $user (@$users) {
        if ($user =~ /^([A-Za-z_]+[\w]*)$/) {
            $user = $1;
            if ($options{U} or !$options{T}) {
                if (!$passwd{$user}) {
                    $msg = "Will not delete account for user \"$user\": protected, or not present.\n";
                    print $msg if defined $options{v};
                    log_message($msg) if defined $lfh;
                }
                else {
                    push @{ $$victims{accounts} }, $user;
                }
            }
            if ($options{T} or !$options{U}) {
                if ($options{T}) {
                    push @{ $$victims{tables} }, $user;
                }
                else {
                    if (!$passwd{$user}) {
                        $msg = "Will not delete tables with prefix \"$user\": doesn't match removable system account.\n";
                        print $msg if defined $options{v};
                        log_message($msg) if defined $lfh;
                    }
                    else {
                        push @{ $$victims{tables} }, $user;
                    }
                }
            }
        }
        else {
            print "Ignoring invalid username \"$user\"\n" if defined $options{v};
        }
    }
}

sub autoconf {
    my $msg;
    my $file = $File::Find::name;
    return unless -f $file;
    return unless $file =~ /blog(?:\d?)\/wp-config\.php$/;
    $msg = "Checking config in file \"$file\"\n";
    print $msg if defined $options{v};
    log_message($msg) if defined $lfh;
    eval {
        open FILE, "<", $file or die;
    };
    if ($@) {
        $msg = "WARNING: Could not open file \"$file\", ignoring\n";
        print $msg if defined $options{v};
        log_message($msg) if defined $lfh;
        return;
    }
    my ($db_name, $db_user, $db_passwd, $db_host, $table_prefix);
    while (<FILE>) {
        chomp();
        my $line = $_; 
        if ($line =~ /'DB_NAME'.*'(\w+)'/) {
            $db_name = $1; 
        }   
        elsif ($line =~ /'DB_USER'.*'(\w+)'/) {
            $db_user = $1; 
        }   
        elsif ($line =~ /'DB_PASSWORD'.*'(\w+)'/) {
            $db_passwd = $1; 
        }   
        elsif ($line =~ /'DB_HOST'.*'([\w\.]+)'/) {
            $db_host = $1; 
        }   
        elsif ($line =~ /\$table_prefix.*'(\w+)'/) {
            $table_prefix = $1; 
        }   
    }   
    close FILE;
    $ac_db_creds{$db_name} = join ':', ($db_user, $db_passwd) unless defined $ac_db_creds{$db_name};

    if ($db_host ne $config{db_host}) {
        $file =~ /^\/Users\/(\w+)\//;
        my $user = $1;
        $msg = "WARNING: DB_HOST mismatch; ignoring tables for user \"$user\"\n"; 
        print $msg if defined $options{v};
        log_message($msg) if defined $lfh;
    }
    else {
        push @{ $ac_databases{$db_name} }, $table_prefix if defined $table_prefix;
    }
}

sub delete_users {
    my ($users) = @_;
    my $msg;
    foreach my $user (@{$$users}) {
        my @userdel_cmd = (
            "/usr/sbin/userdel",
            "$user",
        );
        my @zfs_cmd = (
            "/usr/sbin/zfs",
            "destroy",
            "-r",
            "rawshomepool/$user",
        );    
        if (!$options{n}) {
            $msg = "Removing \"$user\" account from system";
            print $msg if defined $options{v};
            log_message($msg) if defined $lfh;
            system(@userdel_cmd);
            $msg = "Destroying \"rawshomepool/$user\" filesystem";
            print $msg if defined $options{v};
            log_message($msg) if defined $lfh;
            system(@zfs_cmd);
        }
        else {
            if (defined $options{v}) {
                print "TEST: Execute \"@userdel_cmd\"\n";
                print "TEST: Execute \"@zfs_cmd\"\n";
            }
        }
    }
}

sub delete_tables {
    my ($prefixes, $ac_databases, $ac_db_creds) = @_;
    my $msg;
    my ($dbh, $dsn, $sth, @record, @tables, $prefix);
    my $num_db = keys %{$ac_db_creds};
    if ($num_db > 0) {
        foreach my $database (keys %{$ac_db_creds}) {
            my ($db_user, $db_passwd) = split ':', $$ac_db_creds{$database};
            if (defined @{$$ac_databases{$database}}) {
                $dsn = "dbi:mysql:$database:$config{db_host}";
                eval {
                    $dbh = DBI->connect($dsn, $db_user, $db_passwd, {
                                        PrintError => 0,
                                        RaiseError => 1,
                                        AutoCommit => 1, }) or die;
                };
                if ($@) {
                    dbi_error();
                    exit 1;
                }
                    
                foreach $prefix (@{$$ac_databases{$database}}) {
                    my $count = 0;
                    my @records = ();
                    $sth = $dbh->prepare("SHOW TABLES LIKE \"$prefix%\"");
                    $sth->execute();
                    while(@record = $sth->fetchrow_array()) {
                        push (@records, @record);
                        push (@tables, @record);
                        $count++;
                    }
                    if ($count == 0) {
                        $msg = "No tables to drop for prefix \"$prefix\"\n";
                        print $msg if $options{v};
                        log_message($msg) if defined $lfh;
                        next;
                    }
                    if ($options{v}) {
                        $msg = "$count tables to drop with prefix \"$prefix\"\n";
                        print $msg;
                        log_message($msg) if defined $lfh;
                        $msg = "Tables to be dropped: @records\n";
                        print $msg;
                        log_message($msg) if defined $lfh;
                    }
                }
                return if @tables == 0;
                if (!$options{n}) {
                    $sth = $dbh->prepare("DROP TABLE ".(join", ", @tables));
                    $sth->execute();
                    $msg = "Tables dropped\n";
                    print $msg if defined $options{v};
                    log_message($msg) if defined $lfh;
                }
                else {
                    $msg = "TEST: Tables dropped\n";
                    print $msg if defined $options{v};
                }
                $dbh->disconnect();
                if ($@) {
                    dbi_error();
                    exit 1;
                }
            }
            else {
                $msg = "WARNING: No prefixes supplied for database \"$database\"\n";
                print $msg if defined $options{v};
                log_message($msg) if defined $lfh;
            }
        }
    }
    else {
        $dsn = "dbi:mysql:$config{db_name}:$config{db_host}";
        eval {
            $dbh = DBI->connect($dsn, $config{db_user}, $config{db_passwd}, {
                                PrintError => 0,
                                RaiseError => 1,
                                AutoCommit => 1, }) or die;
        };
        if ($@) {
            dbi_error();
            exit 1;
        }

        foreach $prefix (@{$$prefixes}) {
            my $count = 0;
            my @records = ();
            $sth = $dbh->prepare("SHOW TABLES LIKE \"$prefix%\"");
            $sth->execute();
            while(@record = $sth->fetchrow_array()) {
                push (@records, @record);
                push (@tables, @record);
                $count++;
            }
            if ($count == 0) {
                $msg = "No tables to drop for prefix \"$prefix\"\n";
                print $msg if $options{v};
                log_message($msg) if defined $lfh;
                next;
            }
            if ($options{v}) {
                $msg = "$count tables to drop with prefix \"$prefix\"\n";
                print $msg;
                log_message($msg) if defined $lfh;
                $msg = "Tables to be dropped: @records\n";
                print $msg;
                log_message($msg) if defined $lfh;
            }
        }
        return if @tables == 0;
        if (!$options{n}) {
            $sth = $dbh->prepare("DROP TABLE ".(join", ", @tables));
            $sth->execute();
            $msg = "Tables dropped\n";
            print $msg if defined $options{v};
            log_message($msg) if defined $lfh;
        }
        else {
            $msg = "TEST: Tables dropped\n";
            print $msg if defined $options{v};
        }
        $dbh->disconnect();
        if ($@) {
            dbi_error();
            exit 1;
        }
    }
}

sub dbi_error {
    my $msg = "ERROR: $DBI::errstr\n";
    print STDERR $msg;
    if (defined $lfh) {
        log_message($msg);
        close_log();
    }
}

sub HELP_MESSAGE {
    print "Usage: rawsuserdel [-hnvV] -A [-c file] [-h hostname] [-d database]\n";
    print "                   [-u dbuser ] [-m UID] -f file | username...\n\n";
    print "       rawsuserdel [-hnvV] -T [-c file] [-h hostname] [-d database]\n";
    print "                   [-u dbuser] -f file | prefix...\n\n"; 
    print "       rawsuserdel [-hnvV] -U [-c file] [-m UID] -f file | username...\n\n";
    print "   -n             Test mode\n";
    print "   -v             Be verbose\n";
    print "   -V, --version  Prints version message and exits\n";
    print "   -A             Get database details from user config files\n";
    print "   -U             Delete user only, leave database tables alone\n";
    print "   -T             Delete database tables only, leave user alone\n";
    print "   -c             Get configuration from file\n";
    print "   -h             Specify database host (override config file)\n";
    print "   -d             Specify database name (override config file)\n";
    print "   -u             Specify database username (override config file)\n";
    print "   -m             Specify minimum UID (override config file)\n";
    print "   -f             Get usernames or prefixes from file\n";
    print "       --help     Prints this message and exits\n";
    print "   username       Existing RAWS user\n";
    print "   prefix         RAWS database table prefix\n";
}

sub VERSION_MESSAGE {
    print "rawsuserdel version $VERSION\n";
}

# vi: set tabstop=4 shiftwidth=4 expandtab si ai nu:
