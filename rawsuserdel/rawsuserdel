/bin/echo 'Check that #! is set correctly!'; exit
#!/usr/bin/perl -T
# $Id$

=pod

=head1 NAME

rawsuserdel - delete system users and database tables from RAWS

=head1 SYNOPSIS

    rawsuserdel [-A] [-nvV] [-c file] [-h hostname] [-d database]
                [-u dbuser ] [-m UID] (-f file | username...)

    rawsuserdel  -T [-nvV] [-c file] [-h hostname] [-d database]
                [-u dbuser] (-f file | prefix...)

    rawsuserdel  -U [-nvV] [-c file] [-m UID] (-f file | username...)

=head1 DESCRIPTION

For each I<username> entered on the command line (or contained in a I<file>, one
user per line), C<rawsuserdel> executes C<userdel> to delete the user's account,
C<zfs> to delete the user's associated ZFS filesystem, and then gets and drops a
list of tables from the database that have a prefix that matches the username.

There are three modes of operation, chosen via command-line option:

=over 10

=item -A

Auto-config mode

=item -U

User-delete mode

=item -T

Table-drop mode

=back

In the absence of any explicitly defined mode, I<User-delete> and I<Table-drop> will
both be invoked using configuration options obtained from the configuration file
and any command-line overrides.

=head1 OPTIONS

=over 15

=item -A

Get database details from user C<wp-config.php> files.

=item -U

Delete user only, leave database tables alone.

=item -T

Delete database tables only, leave user alone.

=item -n

Test mode.  Does not make any changes.

=item -v

Be verbose.  If not selected, only errors will be shown.

=item -V, --version

Prints version message and exits.

=item -c 

Get configuration from I<file>.

=item -h

Specify database host (override script config file.)

=item -d

Specify database name (override script config file.)

=item -u

Specify database username (override script config file.)

=item -m

Specify minimum allowed UID (override script config file.)

=item -f

Get usernames or prefixes from I<file>.

=item --help

Prints usage message and exits.

=item username

Existing RAWS user.

=item prefix

RAWS database table prefix.

=back

=head1 CONFIGURATION

C<rawsuserdel> gets its configuration from the I<rawsuserdel.cf> file in one of the
following locations (in order of preference):

=over

=item *

The same directory that the script is in

=item *

/usr/local/etc

=item *

/etc

=back

Alternatively, the I<file> pointed at by the -c option will be used.  See the
C<rawsuserdel.cf> file for configuration directives.

=head1 EXIT STATUS

0 on success.

1 on error.

2 on SIGINT.

=head1 BUGS AND LIMITATIONS

You cannot use this utility to delete users with a UID below the I<min_uid>
configuration setting.  In addition to this, you cannot delete the root user,
nor can you delete the nobody, nobody4, and noaccess users (even though these
three have UIDs greater than the default min_uid setting of 501.)  This is
intentional.

There are no known bugs at this time.  Please report any that you find to the
author.  Fixes are welcome.

=head1 AUTHOR

Adrian Waters <adrian.waters@rmit.edu.au>

=cut

# Set up module imports and pragmas.

$|++;                           # Auto-flush.
use strict;                     # Naturally.
use warnings;                   # Ditto.
use File::Basename;             # For basename().
use Getopt::Std;                # For getopts().
use File::Find;                 # For find().
use POSIX "strftime";           # For strftime() when logging.
use Sys::Hostname;              # For hostname.
use DBI;                        # For MySQL access (requires DBD:mysql)

# Script version.

our $VERSION = 0.1;

# As recommended in Getopt::Std docs.

$Getopt::Std::STANDARD_HELP_VERSION = 1;

# Clean up environment and path for Taint mode.

delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};
$ENV{PATH} = "/bin:/usr/bin";

# Set up INT signal handler.

$SIG{"INT"} = "INT_handler";

# Setting these for ease of logging.

my $cmd_name = basename("$0");
my $hostname = hostname;

# Get command-line options.

my %options = ();
if (!getopts("c:h:nAUTvVd:u:m:f:", \%options)) {
    exit 1;
}

# Print version message if requested, or help message if user did not invoke the
# command correctly.

if ($options{V}) {
    VERSION_MESSAGE();
    exit 0;
}

if ( (!$options{f} and @ARGV == 0) or ($options{T} and $options{U}) or
      ($options{U} and $options{A}) or ($options{T} and $options{A}) ) {
    VERSION_MESSAGE();
    HELP_MESSAGE();
    exit 1;
}

# User has to run this script as root.  Theoretically with the use of Taint mode
# this script could be set SUID root, but this is probably useful for that
# little extra bit of safety.

die "Need to run as root.\n" unless ($< == 0);

# Either use the config file specified on the command line, or try to find it in
# one of the default locations.

my $conf_file;

if ($options{c}) {
    $conf_file = $options{c};
}
else {
    $conf_file = find_conf();
}

die "ERROR: Could not find config file.\n" unless defined $conf_file;

# Default config values.  These are commented out by default in the config file
# and thus ignored, so we need to ensure they are set.

my %config = (
    min_uid   => "501",
    db_host   => "localhost",
    db_name   => "example",
    db_user   => "admin",
    db_passwd => "s3kr1t",
);

# Read and action the config file.

parse_config($conf_file, \%config);
enact_config(\%config);

# Save the log file handle if the log file was opened.  This is used as a flag
# for the rest of the script to determine if a message should be logged.

my $lfh = fileno(LOG);

# Create a hash of all valid user accounts on the system.  This will allow for
# faster processing by circumventing the need to continually loop through the 
# system users when checking each input username to see if it exists.

my %passwd = ();
hash_passwd(\%passwd) unless defined $options{T};

# Retrieve and store the requested usernames to remove from the system.

my @users = ();
get_users(\@users);

# Check that the users are valid and build a list of users and tables to delete.
# The hash will have two keys ("accounts" and "tables") that contain lists of
# usernames and table prefixes.

my %victims = ();
get_victims(\%victims, \@users);

# If the user invoked the script with the "-A" autoconfig option the following
# two hashes will be populated.  Keys in %ac_databases will be database names
# retrieved from checking DB_NAME in the user wp-config.php files, with values
# for each key being a list of prefixes in that database.  %ac_db_creds
# contains the DB_USER and DB_PASSWORD values for each database key.

my %ac_databases = ();
my %ac_db_creds = ();

if ($options{A}) {

# Get the list of valid user accounts and check each one for a wp-config.php
# file using the autoconf() function.

    foreach my $user (@{$victims{accounts}}) {
        find({ wanted => \&autoconf, untaint => 1, untaint_skip => 1, }, "/Users/$user/public_html/");
    }
}

# Delete the users (unless "-T" was specified), then delete the users' database
# tables (unless "-U" was specified.)

delete_users(\$victims{accounts}) unless defined $options{T};
delete_tables(\$victims{tables}, \%ac_databases, \%ac_db_creds) unless defined $options{U};

# Close the log file if it was open.

close_log() if defined $lfh;

exit 0;

# All done. :)


#### Functions.

# INT_handler() - Intercepts the INT signal, closing the log file if it is open.

sub INT_handler {
    print "\nCaught SIGINT, exiting.\n";
    if (defined fileno(LOG)) {
        log_message("Caught SIGINT, exiting.");
        close_log();
    }
    exit 2;
} # End INT_handler.


# find_conf() - Looks for the config file.

sub find_conf {

# Check the directory where rawsuserdel is located first.

    if (-e "$0".".cf" ) {
        return "$0".".cf";
    }
    else {

# If not found, check /usr/local/etc, then /etc.  If it isn't found the function
# will return without having set $conf_file.

        foreach my $default_file ( ("/usr/local/etc/$cmd_name.cf", "/etc/$cmd_name.cf") ) {
            if (-e $default_file) {
                return $default_file;
            }
        }
   }
   return undef;
} # End find_conf.


# parse_config() - Parses the config file.  Requires the name of the file and a
# reference to the %config hash.

sub parse_config {
    my ($file, $config) = @_;
    my $line;
    open FILE, "<", $file or die "ERROR: Could not open $file\n";
    while (<FILE>) {
        $line = $_;                                     # Read line from file.
        chomp ($line);                                  # Remove newline from end of line.
        $line =~ s/^\s+//;                              # Strip leading whitespace.
        $line =~ s/\s+$//;                              # Strip trailing whitespace.
        if ($line !~ /^#/ and $line ne "") {            # Ignore comments or blanks. 
            $line =~ s/^(\S*)\s+=\s+(\S*)$/$1=$2/;      # Strip whitespace around "=".
            $line =~ s/^(.*)=[\'\"](.*)[\'\"]$/$1=$2/;  # Strip quotes from value.
            my ($key, @value) = split /=/, $line;       # Split option from value.
            $$config{$key} = join '=', @value;          # Load option and value into hash.
        }
    }
    close FILE;
} #end parse_config.


# enact_config() - Checks that the retrieved values are appropriate and acts
# on them if required.  Requires a reference to the %config hash.

sub enact_config {
    my ($config) = @_;
    my $msg;
    my $lfh;

# If not running in "-T" mode, untaint $min_uid and check that it is in the
# correct range.

    if (!$options{T} and defined $options{m}) {
        if ($options{m} =~ /^(\d+)$/ and $options{m} >= 501 ) {
            $$config{min_uid} = $1;
        }
        else {
            die "ERROR:  Invalid minimum UID specified.\n";
        }
    }
    elsif ($options{T} and defined $options{m}) {
        print "The \"-T\" option is set, ignoring minimum UID override.\n" if defined $options{v};
    }

# Open the log file if the script isn't running in test mode.

    if ($$config{log_file} and !$options{n}) {
        open_log($$config{log_file});
    }

# Replace database configuration values obtained from the config file with the
# ones provided by the user from the command line.  Ask the user for the
# database user password if a database user override was specified.  This is
# only valid if "-U" mode was not requested.

    if (!$options{U}) {
        if ($options{h}) {
            $$config{db_host} = $options{h};
        }

        if ($options{d}) {
            $$config{db_name} = $options{d};
        }

        if ($options{u}) {
            $$config{db_user} = $options{u};
            print "Enter password for \"$$config{db_name}\" user \"$$config{db_user}\": ";
            system ("stty -echo");
            $$config{db_passwd} = <STDIN>; 
            chomp($$config{db_passwd});
            system ("stty echo");
            print "\n";
        }

# Test that the details are correct by connecting to the database.
# Interestingly, Perl doesn't complain that the user input is tainted.
# Not sure if this means that DBI untaints it, or this isn't something
# that needs to be worried about.

        print "Testing connection to database \"$$config{db_name}\" (Host: \"$$config{db_host}\" User: \"$$config{db_user}\") ...\n" if defined $options{v};
        my $dsn = "dbi:mysql:$$config{db_name}:$$config{db_host}";
        my $dbh;
        eval {
            $dbh = DBI->connect($dsn, $$config{db_user}, $$config{db_passwd}, {
                                PrintError => 0,
                                RaiseError => 1,
                                AutoCommit => 1, }) or die;
        };
        if ($@) {
            dbi_error();
            exit 1;
        }
        eval {
            $dbh->disconnect();
        };
        if ($@) {
            dbi_error();
            exit 1;
        }
        print "Test successful.\n" if defined $options{v};
    }

# Ignore database overrides if we're only deleting users.

    elsif ($options{U} and ($options{h} or $options{d} or $options{u})) {
        print "The \"-U\" option is set, ignoring database config overrides.\n" if defined $options{v};
    }
} # End enact_config.


# open_log() - Opens the log file.  Requires a reference to the file name.

sub open_log {
    my ($log_file) = @_;

# Untaint the file name and open it if valid.  Append to an existing file, or create a
# new one if there isn't one in existence.

    if ($log_file =~ /(^[\w\.-\/]+)$/ ) {
        $log_file = $1;
        if (-e $log_file) {
            open LOG, ">>", $log_file or die "ERROR: Could not open log file.\n";
        }
        else {
            open LOG, ">", $log_file or die "ERROR: Could not open log file.\n";
        }

# Put a timestamp in the log to indicate when the script started.

        log_message("--- $cmd_name BEGIN ---");
    }
    else {
        die "ERROR: Invalid log file specified.\n";
    }
} # End open_log.


# close_log() - Timestamp the end of the script and close the log file.

sub close_log {
    log_message("--- $cmd_name END ---");
    close LOG;
} # End close_og.


# log_message() - Write a message to the log file.  Requires a reference
# to the message string to write.

sub log_message {
    my @msg = @_;
    chomp(@msg);

# Writes out time (Month, Day, HH:MM:SS), command name, command PID, and the message.

    printf LOG "%s %s %s[%s]: %s\n", strftime("%b %e %H:%M:%S", localtime), $hostname, $cmd_name, $$, @msg;
} # End log_message.


# hash_passwd() - Creates a hash of all the system accounts.  This is to assist
# checking each input user name for validity; quicker to look up in a hash
# than to cycle through every system user for each input user name.  Requires
# a reference to the %passwd hash.

sub hash_passwd {
    my ($passwd) = @_;

# setpwent() is used rather than checking /etc/passwd because this script was
# developed on Mac OS X which uses Open Directory, not /etc/passwd.  Of
# course, this will still be useful if RAWS ever goes fully LDAP. :)

# A username will only make it into the hash if its UID is not less than
# min_uid, and the username is not root, nobody, nobody4, or noaccess.

    setpwent();
    while (my ($user, $uid) = (getpwent())[0,2]) {
        $$passwd{$user} = 1  unless $uid < $config{min_uid} or $user =~ /^(?:root|no(?:body|access))/;
    }
    endpwent();
} #End hash_passwd.


# get_users() - Get the list of users/table prefixes to delete from either
# the command line or the specified input file.  Requires a reference to
# the @users array.

sub get_users {
    my ($users) = @_;
    my $msg;
    if ($options{f}) {
        eval {
            open FILE, "<", $options{f} or die;
        };
        if ($@) {
            $msg = "ERROR: Could not open data file \"$options{f}\"\n";
            print STDERR $msg;
            if (defined $lfh) {
                log_message($msg);
                close_log();
            }
            exit 1; 
        }
        @$users = <FILE>;
        close FILE;
    }
    else {
        push @$users, @ARGV;
    }
} # End get_users.


# get_victims() - Check every user in the @users array to see if it is
# valid (ie, referenced in the %passwd hash) for those modes that delete
# user accounts, and add the username to the list of table prefixes to
# delete.  Requires references to the %victims hash and @users array.

sub get_victims {
    my ($victims, $users) = @_;
    my $msg;
    foreach my $user (@$users) {

# Remove any newlines from the user name and untaint.        

        chomp($user);
        $user =~ s/^\s+//;                        # Strip leading whitespace.
        $user =~ s/\s+$//;                        # Strip trailing whitespace.
        if ($user !~ /^#/ and $user ne "") {      # Check for comment or blank. 
            if ($user =~ /^([A-Za-z_]+[\w]*)$/) {
                $user = $1;

# If we are deletng system users, ensure that username is one that we can
# delete.  Copy the username to the list of accounts if valid.

                if ($options{U} or !$options{T}) {
                    if (!$passwd{$user}) {
                        $msg = "Will not delete account for user \"$user\": protected, or not present.\n";
                        print $msg if defined $options{v};
                        log_message($msg) if defined $lfh;
                    }
                    else {
                        push @{ $$victims{accounts} }, $user;
                    }
                }

# If we are deleting tables, add the username to the list of table prefixes
# to delete.

                if ($options{T} or !$options{U}) {
                    if ($options{T}) {
                        push @{ $$victims{tables} }, $user;
                    }
                    else {

# If run with the "-A" option, ensure that the requested username is one
# whose tables we can delete by checking the %passwd hash.  Copy the username
# to the list of table prefixes if valid.

                        if (!$passwd{$user}) {
                            $msg = "Will not delete tables with prefix \"$user\": doesn't match removable system account.\n";
                            print $msg if defined $options{v};
                            log_message($msg) if defined $lfh;
                        }
                        else {
                            push @{ $$victims{tables} }, $user;
                        }
                    }
                }
            }
# Alert the user that the username was invalid if we are being verbose,
# but only if the username was not set to a blank line or comment when
# retrieved from the input file.

            else {
                print "Ignoring invalid username \"$user\"\n" if defined $options{v};
            }   
        }
    }
} # End  get_victims.

# autoconf() - Used by the find() function in File::Find to search for a file
# (in this case wp-config.php in users' public_html directories.)  If found,
# this function opens the file and reads the various Wordpress database
# settings from it.

sub autoconf {
    my $msg;
    my $file = $File::Find::name;
    return unless -f $file;
    return unless $file =~ /blog(?:\d?)\/wp-config\.php$/; # "blog" or "blog2".
    $msg = "Checking config in file \"$file\"\n";
    print $msg if defined $options{v};
    log_message($msg) if defined $lfh;

# Catch any failure with opening the config file; we'll use the default config
# instead.

    eval {
        open FILE, "<", $file or die;
    };
    if ($@) {
        $msg = "WARNING: Could not open file \"$file\", ignoring.\n";
        print $msg if defined $options{v};
        log_message($msg) if defined $lfh;
        return;
    }

# Read each line from the found config file and store the value if it
# matches what we are looking for.

    my ($db_name, $db_user, $db_passwd, $db_host, $table_prefix);
    while (<FILE>) {
        chomp();
        my $line = $_; 
        if ($line =~ /'DB_NAME'.*'(\w+)'/) {
            $db_name = $1; 
        }   
        elsif ($line =~ /'DB_USER'.*'(\w+)'/) {
            $db_user = $1; 
        }   
        elsif ($line =~ /'DB_PASSWORD'.*'(\w+)'/) {
            $db_passwd = $1; 
        }   
        elsif ($line =~ /'DB_HOST'.*'([\w\.]+)'/) {
            $db_host = $1; 
        }   
        elsif ($line =~ /\$table_prefix.*'(\w+)'/) {
            $table_prefix = $1; 
        }   
    }   
    close FILE;

# Store the credentials for the database (unless they've already been stored.)

    $ac_db_creds{$db_name} = join ':', ($db_user, $db_passwd) unless defined $ac_db_creds{$db_name};

# If the user's config file is set to use a database server different from the
# one specified in the script's config file ignore the user settings (but raise
# an alert so the admin can investigate.  If they do match, add the table prefix
# to the list of prefixes to act on in the database hash.

    if ($db_host ne $config{db_host}) {
        $file =~ /^\/Users\/(\w+)\//;
        my $user = $1;
        $msg = "WARNING: DB_HOST mismatch; ignoring tables for user \"$user\".\n"; 
        print $msg if defined $options{v};
        log_message($msg) if defined $lfh;
    }
    else {
        push @{ $ac_databases{$db_name} }, $table_prefix if defined $table_prefix;
    }
} # End autoconf.


# delete_users() - Removes user system accounts and associated ZFS filesystems.
# Requires a reference to the @users array.

sub delete_users {
    my ($users) = @_;
    my $msg;

# For each username in the array, set up the relevant userdel and zfs command.

    foreach my $user (@{$$users}) {
        my @userdel_cmd = (
            "/usr/sbin/userdel",
            "$user",
        );
        my @zfs_cmd = (
            "/usr/sbin/zfs",
            "destroy",
            "-r",
            "rawshomepool/$user",
        );    

# Execute the commands if not running in test mode.

        if (!$options{n}) {
            $msg = "Removing \"$user\" account from system.\n";
            print $msg if defined $options{v};
            log_message($msg) if defined $lfh;
            system(@userdel_cmd);

# Catch and alert on any error when executing userdel.  Don't execute the
# zfs command if we couldn't delete the user.

            if ($?) {
                $msg = "WARNING: userdel for \"$user\" failed. [".($? == -1 ? $? : $?  >> 8)."]\n";
                print $msg;
                log_message($msg) if defined $lfh;
            }
            else {
                $msg = "Destroying \"rawshomepool/$user\" filesystem.\n";
                print $msg if defined $options{v};
                log_message($msg) if defined $lfh;

# Catch and alert on any error when destroying the user's filesystem.

                system(@zfs_cmd);
                if ($?) {
                    $msg = "WARNING: removal of \"$zfs_cmd[3]\" filesystem failed. [".($? == -1 ? $? : $? >> 8)."]\n";
                    print $msg;
                    log_message($msg) if defined $lfh;
                }
            }
        }
        else {

# Running in test mode; say what we will do, but don't do it.

            if (defined $options{v}) {
                print "TEST: Removing \"$user\" account from system.\n";
                print "TEST: Destroying \"$zfs_cmd[3]\" filesystem.\n";
            }
        }
    }
} # End delete_users.

# delete_tables() - Drops tables from the RAWS database.  Requires references
# to the array of prefixes to delete, and the two autoconfig hashes.

sub delete_tables {
    my ($prefixes, $ac_databases, $ac_db_creds) = @_;
    my $msg;
    my ($dbh, $dsn, $sth, @record, @tables, $prefix);

# Check if the autoconfig hashes were populated.

    my $num_db = keys %{$ac_db_creds};
    if ($num_db > 0) {

# If the autoconfig hashes were populated, retrieve the details and
# act on the,

        foreach my $database (keys %{$ac_db_creds}) {

# Get the database credentials.

            my ($db_user, $db_passwd) = split ':', $$ac_db_creds{$database};

            if (defined @{$$ac_databases{$database}}) {

# Attempt to connect to the database if there are tables to drop.

                $dsn = "dbi:mysql:$database:$config{db_host}";
                eval {
                    $dbh = DBI->connect($dsn, $db_user, $db_passwd, {
                                        PrintError => 0,
                                        RaiseError => 1,
                                        AutoCommit => 1, }) or die;
                };
                if ($@) {
                    dbi_error();
                    exit 1;
                }

# Get the list of tables that match the table prefix.  Return if there
# are no matches.

                get_tables(\$$ac_databases{$database}, $dbh, \@tables);   
                return if @tables == 0;

# Drop the tables.

                drop_tables($dbh, \@tables);

                eval {
                    $dbh->disconnect();
                };
                if ($@) {
                    dbi_error();
                    exit 1;
                }
            }
            else {

# Alert if there were no prefixes queued up for the database.

                $msg = "WARNING: No prefixes supplied for database \"$database\"\n";
                print $msg if defined $options{v};
                log_message($msg) if defined $lfh;
            }
        }
    }
    else {

# Not using autoconfig.  As per the above, but use the database details
# provided in the config file or at the command line.

        $dsn = "dbi:mysql:$config{db_name}:$config{db_host}";
        eval {
            $dbh = DBI->connect($dsn, $config{db_user}, $config{db_passwd}, {
                                PrintError => 0,
                                RaiseError => 1,
                                AutoCommit => 1, }) or die;
        };
        if ($@) {
            dbi_error();
            exit 1;
        }

        get_tables($prefixes, $dbh, \@tables);   
        return if @tables == 0;

        drop_tables($dbh, \@tables);

        eval {
            $dbh->disconnect();
        };
        if ($@) {
            dbi_error();
            exit 1;
        }
    }
} # End delete_tables.


# dbi_error() - Prints and logs any errors that occur when accessing the
# database.

sub dbi_error {
    my $msg = "ERROR: $DBI::errstr\n";
    print STDERR $msg;
    if (defined $lfh) {
        log_message($msg);
        close_log();
    }
} # End dbi_error.


# dbi_warn() - Prints and logs any non-fatal errors that occur when
# accessing the database.

sub dbi_warn {
   my $msg = "WARNING: $DBI::errstr\n";
   print STDERR $msg;
   if (defined $lfh) {
       log_message($msg);
   }
} # End dbi_warn.


# get_tables() - Retrieves a list of tables from the database that match
# the table prefix.  Requires references to the array of prefixes, the
# database handle, and an array to store the results in.

sub get_tables {
    my ($prefixes, $dbh, $tables) = @_;
    my ($count, $msg);
    my ($sth, $prefix, @record, @records);

# Get a list of tables that match each prefix.  If there are errors,
# consider them warnings rather than fatal errors and go to the next
# prefix.

    foreach $prefix (@{$$prefixes}) {
        $count = 0;
        @records = (); # Intermediary array, for logging purposes.
        eval {
            $sth = $dbh->prepare("SHOW TABLES LIKE \"$prefix%\"");
        };
        if ($@) {
            dbi_warn();
            next;
        }
        eval {
            $sth->execute();
        };
        if ($@) {
            dbi_warn();
            next;
        }

# Retrieve each row from the query result, push it into the temporay
# @records array, and the @tables results array.

        while(@record = $sth->fetchrow_array()) {
            push (@records, @record);
            push (@{$tables}, @record);
            $count++;
        }

# Report if no tables and try the next prefix.

        if ($count == 0) {
            $msg = "No tables to drop with prefix \"$prefix\".\n";
            print $msg if $options{v};
            log_message($msg) if defined $lfh;
            next;
        }

# Report on the list of found tables.

        $msg = "$count tables to drop with prefix \"$prefix\".\n";
        log_message($msg) if defined $lfh;
        $msg = "Tables to be dropped: @records\n";
        print $msg if defined $options{v};
        log_message($msg) if defined $lfh;
    }
} # End of get_tables.


# drop_tables() - Drops the tables specifed in a supplied array.
# Requires references to the database handle and an array of database
# tables.

sub drop_tables {
    my ($dbh, $tables) = @_;
    my $msg;
    my $sth;

    if (!$options{n}) {

# If not running in test mode, drop the list of comma-seperated tables.
# Treat any errors as non-fatal, but report on them.

        eval {
            $sth = $dbh->prepare("DROP TABLE ".(join", ", @{$tables}));
        };
        if ($@) {
            dbi_warn();
            return;
        }
        eval {
            $sth->execute();
        };
        if ($@) {
            dbi_warn();
            return;
        }
        $msg = "Tables dropped.\n";
        print $msg if defined $options{v};
        log_message($msg) if defined $lfh;
    }
    else {

# If running in test mode, say we did it, but don't do it.

        $msg = "TEST: Tables dropped.\n";
        print $msg if defined $options{v};
    }
} # End of dropt_tables.


# HELP_MESSAGE() - Help message as used by Getopt::Std. 

sub HELP_MESSAGE {
    print "Usage: $cmd_name [-A] [-nvV] [-c file] [-h hostname] [-d database]\n";
    print "                   [-u dbuser ] [-m UID] (-f file | username...)\n\n";
    print "       $cmd_name  -T [-nvV] [-c file] [-h hostname] [-d database]\n";
    print "                   [-u dbuser] (-f file | prefix...)\n\n"; 
    print "       $cmd_name  -U [-nvV] [-c file] [-m UID] (-f file | username...)\n\n";
    print "   -A             Get database details from user wp-config.php files.\n";
    print "   -U             Delete user only, leave database tables alone.\n";
    print "   -T             Delete database tables only, leave user alone.\n";
    print "   -n             Test mode.  Does not make any changes.\n";
    print "   -v             Be verbose.\n";
    print "   -V, --version  Prints version message and exits.\n";
    print "   -c             Get configuration from file.\n";
    print "   -h             Specify database host (override script config file.)\n";
    print "   -d             Specify database name (override script config file.)\n";
    print "   -u             Specify database username (override script config file.)\n";
    print "   -m             Specify minimum allowed UID (override script config file.)\n";
    print "   -f             Get usernames or prefixes from file.\n";
    print "       --help     Prints usage message and exits.\n";
    print "   username       Existing RAWS user.\n";
    print "   prefix         RAWS database table prefix.\n";
} # End HELP_MESSAGE.


# VERSION_MESSAGE() - Version message as used by Getopt:Std.

sub VERSION_MESSAGE {
    print "$cmd_name version $VERSION\n";
} # End of VERSION_MESSAGE.

# vi: set tabstop=4 shiftwidth=4 expandtab si ai nu:
