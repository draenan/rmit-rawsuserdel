#!/usr/bin/env perl -T
# $Id$

=pod

=head1 NAME

rawsuserdel - delete system users and database tables from RAWS

=head1 SYNOPSIS

    rawsuserdel [-hnvV] -A [-c file] [-h hostname] [-d database]
                [-u dbuser ] [-m UID] -f file | username...

    rawsuserdel [-hnvV] -T [-c file] [-h hostname] [-d database]
                [-u dbuser] -f file | prefix...

    rawsuserdel [-hnvV] -U [-c file] [-m UID] -f file | username...

=head1 DESCRIPTION

For each I<username> entered on the command line (or contained in a I<file>, one
user per line), C<rawsuserdel> executes C<userdel> to delete the user's account,
C<zfs> to delete the user's associated ZFS filesystem, and then gets and drops a
list of tables from the database that have a prefix that matches the username.

There are three modes of operation, chosen via command-line option:

B<-A> Auto-config mode

B<-U> User-delete mode

B<-T> Table-drop mode

In the absence of any explicitly defined mode, User-delete and Table-drop will
both be invoked using configuration options obtained from the configuration file
and any command-line overrides.

=head1 OPTIONS

B<-n> Test mode.  Does not make any changes.

B<-v> Be verbose.  If not selected, only errors will be shown.

B<-V> Prints version message and exits. (Also B<--version>)

B<-A> Get database details from user config files.

B<-U> Delete user only, leave database tables alone.

B<-T> Delete database tables only, leave user alone.

B<-c> Get configuration from file.

B<-h> Specify database host (override config file.)

B<-d> Specify database name (override config file.)

B<-u> Specify database username (override config file.)

B<-m> Specify minimum allowed UID (override config file.)

B<-f> Get usernames or prefixes from file.

B<--help> Prints usage message and exits.

B<username> Existing RAWS user.

B<prefix> RAWS database table prefix.

=head1 CONFIGURATION

rawsuserdel gets its configuration from the rawsuserdel.cf file in one of the
following locations (in order of preference):


- The same directory that the script is in

- /usr/local/etc

- /etc

Alternatively, the file pointed at by the -c option will be used.  See the
rawsuserdel.cf file for configuration directives.

=head1 EXIT STATUS

B<0> on success.

B<1> on error.

=head1 BUGS AND LIMITATIONS

You cannot use this utility to delete users with a UID below the min_uid
configuration setting.  In addition to this, you cannot delete the root user,
nor can you delete the nobody, nobody4, and noaccess users (even though these
three have UIDs greater than the default min_uid setting of 501.)  This is
intentional.

There are no known bugs at this time.  Please report any that you find to the
author.  Fixes are welcome.

=head1 AUTHOR

Adrian Waters <adrian.waters@rmit.edu.au>

=cut

# Set up module imports and pragmas.

$|++;   # Auto-flush
use strict;
use warnings;
use File::Basename;
use Getopt::Std;
use File::Find;
use POSIX "strftime";
use Sys::Hostname;
use DBI;

# Script version.

our $VERSION = 0.1;

# As recommended in Getopt::Std docs.

$Getopt::Std::STANDARD_HELP_VERSION = 1;

# Clean up environment and path for Taint mode.

delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};
$ENV{PATH} = "/bin:/usr/bin";

# Set up INT signal handler.

$SIG{"INT"} = "INT_handler";

# Setting these for ease of logging.

my $cmd_name = basename("$0");
my $hostname = hostname;

# Get command-line options.

my %options = ();
if (!getopts("c:h:nAUTvVd:u:m:f:", \%options)) {
    exit 1;
}

# Print version message if requested, or help message if user did not invoke the
# command correctly.

if ($options{V}) {
    VERSION_MESSAGE();
    exit 0;
}

if ( (!$options{f} and @ARGV == 0) or ($options{T} and $options{U}) or
      ($options{U} and $options{A}) or ($options{T} and $options{A}) ) {
    VERSION_MESSAGE();
    HELP_MESSAGE();
    exit 1;
}

# User has to run this script as root.  Theoretically with the use of Taint mode
# this script could be set SUID root, but this is probably useful for that
# little extra bit of safety.

die "Need to run as root.\n" unless ($< == 0);

# Either use the config file specified on the command line, or try to find it in
# one of the default locations.

my $conf_file;

if ($options{c}) {
    $conf_file = $options{c};
}
else {
    $conf_file = find_conf();
}

die "ERROR: Could not find config file.\n" unless defined $conf_file;

# Default config values.  These are commented out by default in the config file
# and thus ignored, so we need to ensure they are set.

my %config = (
    min_uid   => "501",
    db_host   => "localhost",
    db_name   => "example",
    db_user   => "admin",
    db_passwd => "s3kr1t",
);

# Read and action the config file.

parse_config($conf_file, \%config);
enact_config(\%config);

# Save the log file handle if the log file was opened.  This is used as a flag
# for the rest of the script to determine if a message should be logged.

my $lfh = fileno(LOG);

# Create a hash of all valid user accounts on the system.  This will allow for
# faster processing by circumventing the need to continually loop through the 
# system users when checking each input username to see if it exists.

my %passwd = ();
hash_passwd(\%passwd) unless defined $options{T};

# Retrieve and store the requested usernames to remove from the system.

my @users = ();
get_users(\@users);

# Check that the users are valid and build a list of users and tables to delete.
# The hash will have two keys ("accounts" and "tables") that contain lists of
# usernames and table prefixes.

my %victims = ();
get_victims(\%victims, \@users);

# If the user invoked the script with the "-A" autoconfig option the following
# two hashes will be populated.  Keys in %ac_databases will be database names
# retrieved from checking DB_NAME in the user wp-config.php files, with values
# for each key being a list of prefixes in that database.  %ac_db_creds
# contains the DB_USER and DB_PASSWORD values for each database key.

my %ac_databases = ();
my %ac_db_creds = ();

if ($options{A}) {

# "-A" is only valid if "-T" or "-U" have not been selected.    

    if (!$options{T} and !$options{U}) {

# Get the list of valid user accounts and check each one for a wp-config.php
# file using the autoconf() function.

        foreach my $user (@{$victims{accounts}}) {
            find({ wanted => \&autoconf, untaint => 1 }, "/Users/$user/public_html/");
        }
    }

# These two ELSEs should never execute, but I'm leaving them in.

    elsif ($options{U}) {
        print "The \"-U\" option is set, ignoring \"-A\" option.\n" if defined $options{v};
    }
    else {
        print "The \"-T\" option is set, igonoring \"-A\" option.\n" if defined $options{v};
    }
}

# Delete the users (unless "-T" was specified), then delete the users' database
# tables (unless "-U" was specified.)

delete_users(\$victims{accounts}) unless defined $options{T};
delete_tables(\$victims{tables}, \%ac_databases, \%ac_db_creds) unless defined $options{U};

# Close the log file if it was open.

close_log() if defined $lfh;

exit 0;

# All done. :)

#### Functions.

# INT_handler() - Intercepts the INT signal, closing the log file if it is open.

sub INT_handler {
    print "\nCaught SIGINT, exiting\n";
    if (defined fileno(LOG)) {
        log_message("Caught SIGINT, exiting");
        close_log();
    }
    exit 1;  # Not _really_ an error, but neither is it success.
}

# find_conf() - Looks for the config file.

sub find_conf {

# Check the directory where rawsuserdel is located first.

    if (-e "$0".".cf" ) {
        return "$0".".cf";
    }
    else {

# If not found, check /usr/local/etc, then /etc.  If it isn't found the function
# will return without having set $conf_file.

        foreach my $default_file ( ("/usr/local/etc/$cmd_name.cf", "/etc/$cmd_name.cf") ) {
            if (-e $default_file) {
                return $default_file;
            }
        }
   }
}

# parse_config() - Parses the config file.  Requires the name of the file and a
# reference to the %config hash.

sub parse_config {
    my ($file, $config) = @_;
    my $line;
    open FILE, "<", $file or die "ERROR: Could not open $file\n";
    while (<FILE>) {
        $line = $_;                                     # Read line from file.
        chomp ($line);                                  # Remove newline from end of line.
        $line =~ s/^\s+//;                              # Strip leading whitespace.
        $line =~ s/\s+$//;                              # Strip trailing whitespace.
        if ($line !~ /^#/ and $line ne "") {            # Ignore comments or blanks. 
            $line =~ s/^(\S*)\s+=\s+(\S*)$/$1=$2/;      # Strip whitespace around "=".
            $line =~ s/^(.*)=[\'\"](.*)[\'\"]$/$1=$2/;  # Strip quotes from value.
            my ($key, @value) = split /=/, $line;       # Split option from value.
            $$config{$key} = join '=', @value;          # Load option and value into hash.
        }
    }
    close FILE;
}

# enact_config() - Checks that the retrieved values are appropriate and acts
# on them if required.  Requires a reference to the %config hash.

sub enact_config {
    my ($config) = @_;
    my $msg;
    my $lfh;

# Open the log file if the script isn't running in test mode.

    if ($$config{log_file} and !$options{n}) {
        open_log($$config{log_file});
    }

# If not running in "-T" mode, untaint $min_uid and check that it is in the
# correct range.

    if (!$options{T} and defined $options{m}) {
        if ($options{m} =~ /^(\d+)$/ and $options{m} >= 501 ) {
            $$config{min_uid} = $1;
        }
        else {
            die "ERROR:  Invalid minimum UID specified.\n";
        }
    }
    elsif ($options{T} and defined $options{m}) {
        print "The \"-T\" option is set, ignoring minimum UID override.\n" if defined $options{v};
    }

# Replace database configuration values obtained from the config file with the
# ones provided by the user from the command line.  Ask the user for the
# database user password if a database user override was specified.  This is
# only valid if "-U" mode was not requested.

    if (!$options{U}) {
        if ($options{h}) {
            $$config{db_host} = $options{h};
        }

        if ($options{d}) {
            $$config{db_name} = $options{d};
        }

        if ($options{u}) {
            $$config{db_user} = $options{u};
            print "Enter password for \"$$config{db_name}\" user \"$$config{db_user}\": ";
            system ("stty -echo");
            $$config{db_passwd} = <STDIN>; 
            chomp($$config{db_passwd});
            system ("stty echo");
            print "\n";
        }

# Test that the details are correct by connecting to the database.
# Interestingly, Perl doesn't complain that the user input is tainted.
# Not sure if this means that DBI untaints it, or this isn't something
# that needs to be worried about.

        print "Testing connection to database \"$$config{db_name}\" (Host: \"$$config{db_host}\" User: \"$$config{db_user}\") ...\n" if defined $options{v};
        my $dsn = "dbi:mysql:$$config{db_name}:$$config{db_host}";
        my $dbh;
        eval {
            $dbh = DBI->connect($dsn, $$config{db_user}, $$config{db_passwd}, {
                                PrintError => 0,
                                RaiseError => 1,
                                AutoCommit => 1, }) or die;
        };
        if ($@) {
            dbi_error();
            exit 1;
        }
        eval {
            $dbh->disconnect();
        };
        if ($@) {
            dbi_error();
            exit 1;
        }
        print "Test successful.\n" if defined $options{v};
    }

# Ignore database overrides if we're only deleting users.

    elsif ($options{U} and ($options{h} or $options{d} or $options{u})) {
        print "The \"-U\" option is set, ignoring database config overrides.\n" if defined $options{v};
    }
}

# open_log() - Opens the log file.  Requires a reference to the file name.

sub open_log {
    my ($log_file) = @_;

# Untaint the file name and open it if valid.  Append to an existing file, or create a
# new one if there isn't one in existence.

    if ($log_file =~ /(^[\w\.-\/]+)$/ ) {
        $log_file = $1;
        if (-e $log_file) {
            open LOG, ">>", $log_file or die "ERROR: Could not open log file.\n";
        }
        else {
            open LOG, ">", $log_file or die "ERROR: Could not open log file.\n";
        }

# Put a timestamp in the log to indicate when the script started.

        log_message("--- $cmd_name BEGIN ---");
    }
    else {
        die "ERROR: Invalid log file specified.\n";
    }
}

# close_log() - Timestamp the end of the script and close the log file.

sub close_log {
    log_message("--- $cmd_name END ---");
    close LOG;
}

# log_message() - Write a message to the log file.  Requires a reference
# to the message string to write.

sub log_message {
    my @msg = @_;
    chomp(@msg);

# Writes out time (Month, Day, HH:MM:SS), command name, command PID, and the message.

    printf LOG "%s %s %s[%s]: %s\n", strftime("%b %e %H:%M:%S", localtime), $hostname, $cmd_name, $$, @msg;
}

# hash_passwd() - Creates a hash of all the system accounts.  This is to assist
# checking each input user name for validity;; quicker to look up in a hash
# than to cycle through every system user for each input user name.  Requires
# a reference to the %passwd hash.

sub hash_passwd {
    my ($passwd) = @_;

# setpwent() is used rather than checking /etc/passwd because this script was
# developed on Mac OS X which uses Open Directory, not /etc/passwd.  Of
# course, this will still be useful if RAWS ever goes fully LDAP. :)

# A username will only make it into the hash if its UID is not less than
# min_uid, and the username is not root, nobody, nobody4, or noaccess.

    setpwent();
    while (my ($user, $uid) = (getpwent())[0,2]) {
        $$passwd{$user} = 1  unless $uid < $config{min_uid} or $user =~ /^(?:root|no(?:body|access))/;
    }
    endpwent();
}

# get_users() - Get the list of users/table prefixes to delete from either
# the command line or the specified input file.  Requires a reference to
# the @users array.

sub get_users {
    my ($users) = @_;
    my $msg;
    if ($options{f}) {
        eval {
            open FILE, "<", $options{f} or die;
        };
        if ($@) {
            $msg = "ERROR: Could not open data file \"$options{f}\"\n";
            print STDERR $msg;
            if (defined $lfh) {
                log_message($msg);
                close_log();
            }
            exit 1; 
        }
        @$users = <FILE>;
        close FILE;
    }
    else {
        push @$users, @ARGV;
    }
}

# get_victims() - Check every user in the @users array to see if it is
# valid (ie, referenced in the %oasswd hash) for those modes that delete
# user accounts, and add the username to the list of table prefixes to
# delete.  Requires references to the %victims hash and @users array.

sub get_victims {
    my ($victims, $users) = @_;
    my $msg;
    foreach my $user (@$users) {

# Remove any newlines from the user name and untaint.        

        chomp($user);
        if ($user =~ /^([A-Za-z_]+[\w]*)$/) {
            $user = $1;

# If we are deletng system users, ensure that username is one that we can
# delete.  Copy the username to the list of accounts if valid.

            if ($options{U} or !$options{T}) {
                if (!$passwd{$user}) {
                    $msg = "Will not delete account for user \"$user\": protected, or not present.\n";
                    print $msg if defined $options{v};
                    log_message($msg) if defined $lfh;
                }
                else {
                    push @{ $$victims{accounts} }, $user;
                }
            }

# If we are deleting tables, add the username to the list of table prefixes
# to delete.

            if ($options{T} or !$options{U}) {
                if ($options{T}) {
                    push @{ $$victims{tables} }, $user;
                }
                else {

# If run without one of either the "-T" or "-U" option, ensure that the
# requested username is one that we can delete by checking the %passwd
# hash.  Copy the username to the list of table prefixes if valid.

                    if (!$passwd{$user}) {
                        $msg = "Will not delete tables with prefix \"$user\": doesn't match removable system account.\n";
                        print $msg if defined $options{v};
                        log_message($msg) if defined $lfh;
                    }
                    else {
                        push @{ $$victims{tables} }, $user;
                    }
                }
            }
        }

# Alert the user that the username was invalid if we are being verbose,
# but only if the username was not set to a blank line or comment when
# retrieved from the input file.

        elsif ($user !~ /^#/ and $user ne "") {
            print "Ignoring invalid username \"$user\"\n" if defined $options{v};
        }
    }
}

sub autoconf {
    my $msg;
    my $file = $File::Find::name;
    return unless -f $file;
    return unless $file =~ /blog(?:\d?)\/wp-config\.php$/;
    $msg = "Checking config in file \"$file\"\n";
    print $msg if defined $options{v};
    log_message($msg) if defined $lfh;
    eval {
        open FILE, "<", $file or die;
    };
    if ($@) {
        $msg = "WARNING: Could not open file \"$file\", ignoring.\n";
        print $msg if defined $options{v};
        log_message($msg) if defined $lfh;
        return;
    }
    my ($db_name, $db_user, $db_passwd, $db_host, $table_prefix);
    while (<FILE>) {
        chomp();
        my $line = $_; 
        if ($line =~ /'DB_NAME'.*'(\w+)'/) {
            $db_name = $1; 
        }   
        elsif ($line =~ /'DB_USER'.*'(\w+)'/) {
            $db_user = $1; 
        }   
        elsif ($line =~ /'DB_PASSWORD'.*'(\w+)'/) {
            $db_passwd = $1; 
        }   
        elsif ($line =~ /'DB_HOST'.*'([\w\.]+)'/) {
            $db_host = $1; 
        }   
        elsif ($line =~ /\$table_prefix.*'(\w+)'/) {
            $table_prefix = $1; 
        }   
    }   
    close FILE;
    $ac_db_creds{$db_name} = join ':', ($db_user, $db_passwd) unless defined $ac_db_creds{$db_name};

    if ($db_host ne $config{db_host}) {
        $file =~ /^\/Users\/(\w+)\//;
        my $user = $1;
        $msg = "WARNING: DB_HOST mismatch; ignoring tables for user \"$user\".\n"; 
        print $msg if defined $options{v};
        log_message($msg) if defined $lfh;
    }
    else {
        push @{ $ac_databases{$db_name} }, $table_prefix if defined $table_prefix;
    }
}

sub delete_users {
    my ($users) = @_;
    my $msg;
    foreach my $user (@{$$users}) {
        my @userdel_cmd = (
            "/usr/sbin/userdel",
            "$user",
        );
        my @zfs_cmd = (
            "/usr/sbin/zfs",
            "destroy",
            "-r",
            "rawshomepool/$user",
        );    
        if (!$options{n}) {
            $msg = "Removing \"$user\" account from system.\n";
            print $msg if defined $options{v};
            log_message($msg) if defined $lfh;
            system(@userdel_cmd);
            if ($?) {
                $msg = "WARNING: userdel for \"$user\" failed. [".($? == -1 ? $? : $?  >> 8)."]\n";
                print $msg;
                log_message($msg) if defined $lfh;
            }
            else {
                $msg = "Destroying \"rawshomepool/$user\" filesystem.\n";
                print $msg if defined $options{v};
                log_message($msg) if defined $lfh;
                system(@zfs_cmd);
                if ($?) {
                    $msg = "WARNING: removal of \"$zfs_cmd[3]\" filesystem failed. [".($? == -1 ? $? : $? >> 8)."]\n";
                    print $msg;
                    log_message($msg) if defined $lfh;
                }
            }
        }
        else {
            if (defined $options{v}) {
                print "TEST: Removing \"$user\" account from system.\n";
                print "TEST: Destroying \"$zfs_cmd[3]\" filesystem.\n";
            }
        }
    }
}

sub delete_tables {
    my ($prefixes, $ac_databases, $ac_db_creds) = @_;
    my $msg;
    my ($dbh, $dsn, $sth, @record, @tables, $prefix);
    my $num_db = keys %{$ac_db_creds};
    if ($num_db > 0) {
        foreach my $database (keys %{$ac_db_creds}) {
            my ($db_user, $db_passwd) = split ':', $$ac_db_creds{$database};
            if (defined @{$$ac_databases{$database}}) {
                $dsn = "dbi:mysql:$database:$config{db_host}";
                eval {
                    $dbh = DBI->connect($dsn, $db_user, $db_passwd, {
                                        PrintError => 0,
                                        RaiseError => 1,
                                        AutoCommit => 1, }) or die;
                };
                if ($@) {
                    dbi_error();
                    exit 1;
                }
                get_tables(\$$ac_databases{$database}, $dbh, \@tables);   
                return if @tables == 0;

                drop_tables($dbh, \@tables);

                eval {
                    $dbh->disconnect();
                };
                if ($@) {
                    dbi_error();
                    exit 1;
                }
            }
            else {
                $msg = "WARNING: No prefixes supplied for database \"$database\"\n";
                print $msg if defined $options{v};
                log_message($msg) if defined $lfh;
            }
        }
    }
    else {
        $dsn = "dbi:mysql:$config{db_name}:$config{db_host}";
        eval {
            $dbh = DBI->connect($dsn, $config{db_user}, $config{db_passwd}, {
                                PrintError => 0,
                                RaiseError => 1,
                                AutoCommit => 1, }) or die;
        };
        if ($@) {
            dbi_error();
            exit 1;
        }

        get_tables($prefixes, $dbh, \@tables);   
        return if @tables == 0;

        drop_tables($dbh, \@tables);

        eval {
            $dbh->disconnect();
        };
        if ($@) {
            dbi_error();
            exit 1;
        }
    }
}

sub dbi_error {
    my $msg = "ERROR: $DBI::errstr\n";
    print STDERR $msg;
    if (defined $lfh) {
        log_message($msg);
        close_log();
    }
}

sub dbi_warn {
   my $msg = "WARNING: $DBI::errstr\n";
   print STDERR $msg;
   if (defined $lfh) {
       log_message($msg);
   }
}

sub get_tables {
    my ($prefixes, $dbh, $tables) = @_;
    my ($count, $msg);
    my ($sth, $prefix, @record, @records);
    foreach $prefix (@{$$prefixes}) {
        $count = 0;
        @records = ();
        eval {
            $sth = $dbh->prepare("SHOW TABLES LIKE \"$prefix%\"");
        };
        if ($@) {
            dbi_warn();
            next;
        }
        eval {
            $sth->execute();
        };
        if ($@) {
            dbi_warn();
            next;
        }
        while(@record = $sth->fetchrow_array()) {
            push (@records, @record);
            push (@{$tables}, @record);
            $count++;
        }
        if ($count == 0) {
            $msg = "No tables to drop with prefix \"$prefix\".\n";
            print $msg if $options{v};
            log_message($msg) if defined $lfh;
            next;
        }
        $msg = "$count tables to drop with prefix \"$prefix\".\n";
        log_message($msg) if defined $lfh;
        $msg = "Tables to be dropped: @records\n";
        print $msg if defined $options{v};
        log_message($msg) if defined $lfh;
    }
}

sub drop_tables {
    my ($dbh, $tables) = @_;
    my $msg;
    my $sth;
    if (!$options{n}) {
        eval {
            $sth = $dbh->prepare("DROP TABLE ".(join", ", @{$tables}));
        };
        if ($@) {
            dbi_warn();
            return;
        }
        eval {
            $sth->execute();
        };
        if ($@) {
            dbi_warn();
            return;
        }
        $msg = "Tables dropped.\n";
        print $msg if defined $options{v};
        log_message($msg) if defined $lfh;
    }
    else {
        $msg = "TEST: Tables dropped.\n";
        print $msg if defined $options{v};
    }
}

sub HELP_MESSAGE {
    print "Usage: rawsuserdel [-hnvV] [-A] [-c file] [-h hostname] [-d database]\n";
    print "                   [-u dbuser ] [-m UID] -f file | username...\n\n";
    print "       rawsuserdel [-hnvV] -T [-c file] [-h hostname] [-d database]\n";
    print "                   [-u dbuser] -f file | prefix...\n\n"; 
    print "       rawsuserdel [-hnvV] -U [-c file] [-m UID] -f file | username...\n\n";
    print "   -n             Test mode.  Does not make any changes.\n";
    print "   -v             Be verbose.\n";
    print "   -V, --version  Prints version message and exits.\n";
    print "   -A             Get database details from user config files.\n";
    print "   -U             Delete user only, leave database tables alone.\n";
    print "   -T             Delete database tables only, leave user alone.\n";
    print "   -c             Get configuration from file.\n";
    print "   -h             Specify database host (override config file.)\n";
    print "   -d             Specify database name (override config file.)\n";
    print "   -u             Specify database username (override config file.)\n";
    print "   -m             Specify minimum allowed UID (override config file.)\n";
    print "   -f             Get usernames or prefixes from file.\n";
    print "       --help     Prints this message and exits.\n";
    print "   username       Existing RAWS user.\n";
    print "   prefix         RAWS database table prefix.\n";
}

sub VERSION_MESSAGE {
    print "rawsuserdel version $VERSION\n";
}

# vi: set tabstop=4 shiftwidth=4 expandtab si ai nu:
